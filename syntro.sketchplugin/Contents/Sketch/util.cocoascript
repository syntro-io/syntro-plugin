var console = (function() {
  var persistent = [[NSThread mainThread] threadDictionary];
  var console = persistent.console || '';

  function logWindows() {
    var window = persistentPanel('Console', 'LogWindow', function(window) {
      var scrollview  = [[NSScrollView alloc] initWithFrame:[[window contentView] frame]];
      var contentSize = [scrollview contentSize];

      [scrollview setBorderType:NSNoBorder];
      [scrollview setHasVerticalScroller:true];
      [scrollview setHasHorizontalScroller:true];
      [scrollview setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];

      var FLT_MAX = 3.40282347e+38;
      var view    = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, contentSize.width, contentSize.height)];

      [view setMinSize:NSMakeSize(0.0, contentSize.height)];
      [view setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
      [view setVerticallyResizable:true];
      [view setHorizontallyResizable:true];
      [view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
      [[view textContainer] setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
      [[view textContainer] setWidthTracksTextView:false];

      [scrollview setDocumentView:view];
      [window setContentView:scrollview];
      [window makeFirstResponder:view];
    });

    return window;
  }

  function makePanel(title, autosave, setup) {
    var frame = NSMakeRect(0,0,512,128);
    var mask  = NSTitledWindowMask + NSClosableWindowMask + NSMiniaturizableWindowMask + NSResizableWindowMask + NSUtilityWindowMask;
    var window = [[NSPanel alloc] initWithContentRect:frame styleMask:mask backing:NSBackingStoreBuffered defer:true];

    window.title = title;
    window.floatingPanel = true;
    [window setFrameAutosaveName:autosave];

    setup(window);

    [window setReleasedWhenClosed:false];
    [window makeKeyAndOrderFront:nil];

    return window;
  }

  function persistentPanel(title, persistName, setup) {
    var window = persistent[persistName];
    if (window == null) {
      window = makePanel(title, persistName, setup);
      persistent[persistName] = window;
    }

    return window;
  }

  return {
    log: function(msg) {
      var logWindow = logWindows();
      var time = new Date().toString().split(' ')[4];
      var view = logWindow.contentView().documentView();

      if (Object.prototype.toString.call(msg) == '[object Array]') {
        msg = msg.join(', ');
      }

      if (Object.prototype.toString.call(msg) == '[object Object]') {
        msg = JSON.stringify(msg);
      }

      console = console +'['+ time +']' + ' '+ msg + '\n';
      logWindow.makeKeyAndOrderFront(nil);

      log(msg);
      view.setString(console);
      log(msg);
      persistent.console = console;
      view.scrollRangeToVisible(NSMakeRange(view.string.length, 0));
      [[view textStorage] setFont:[NSFont fontWithName:@"Consolas" size:11]];

    },

    clear: function() {
      var logWindow = logWindows();
      var view      = logWindow.contentView().documentView();

      logWindow.makeKeyAndOrderFront(nil);

      console = '';
      view.setString('');
    }
  }
})();

var util = {

  // Get the text layers font style
  getFontWeight: function(layer) {
    var app        = NSApplication.sharedApplication();
    var appVersion = parseFloat(app.applicationVersion(), 10);

    if (appVersion <= 3.3) {

      var layerFont   = layer.font();
      var fontManager = [NSFontManager sharedFontManager];
      var weight      = fontManager.weightOfFont(layerFont);
      return weight > 7 ? '700' : null;

    } else {
      return null
    }
  },

  // Font Alignment
  getTextAlign: function(layer) {
    var align = ['left', 'right', 'center', 'justify'];
        return align[layer.textAlignment()] ? align[layer.textAlignment()] : null;
  },

  // Convert the version number
  convertVersion: function(version) {
    return parseFloat(version.match(/\d/gi).join(''), 10);
  },

  /*
   * Message Tip
   * obj.title
   * obj.content
   */

  showTips: function(obj) {
    var title = obj.title || 'Marketch';
    var app = [NSApplication sharedApplication];

        [app displayDialog:obj.content withTitle:title];
  },

  // Synchronous load json data from the network
  getJSON: function(url) {
    var url = [NSURL URLWithString:url];
    var request = [NSMutableURLRequest requestWithURL:url];
    var response = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];
    var result = [NSJSONSerialization JSONObjectWithData:response options:nil error:nil];
    return result;
  },

  I18N: (function() {

    var defs = [NSUserDefaults standardUserDefaults];
        var languages = [[defs objectForKey:@"AppleLanguages"] objectAtIndex:0];

    // Multi-language configuration
    var I18N = {
      'zh-cn': {
        'language': 'cn',
        'EXPORT': '导出',
        'EXPORTTO': '导出到：',
        'NOARTBOARD': '没有选择任何画板',
        'EXPORTSUCCESS': '打包导出成功',
        'EXPORTFAIL': '打包导出失败',
        'NEWVERSION': '发现版本（{newversion}），从Toolbox中删除后重新安装可以获取新版本',
        'LAETVERSION': '已经是最新版本了',
        'NETERROR': '无法访问更新服务器，请稍后再试',
        'SELECTEXPORTARTBOARD': '请选择要导出的画板',
        'SELECTEDARTBOARD': '当前选中的画板',
        'ARTBOARDONPAGE': '当前页面上的全部画板',
        'ALLARTBOARD': '所有画板(会比较慢)',
        'EXPORTEVERYLAYER': '把每个图层作为图片导出',
        'REVEALINFINDER': '导出完成后在 Finder 中打开',
        'CONFIRM': '确认',
        'CANCEl': '取消',
        //预览页面多语言
        'MarketchPreview': {
          'UNIT': '单位',
          'SIZE': '尺寸',
          'SHOWSLICE': '显示切片',
          'DRAGTOSAVE': '右键或拖拽到桌面保存',
          'WIDTH': '宽',
          'HEIGHT': '高',
          'BORDER': '边框',
          'COLOR': '颜色',
          'FILLCOLOR': '填充色',
          'RADIUS': '圆角',
          'LAYERTEXT': '图层内容',
          'FONTSIZE': '字号',
          'CODE': '代码',
          'EXPORT': '导出',
          'FORMAT': '格式',
          'EXPORTLAYER': '导出选中图层',
          'COPYSUCCESS': '复制成功'
        }
      },
      'en': {
        'language': 'en',
        'EXPORT': 'Export',
        'EXPORTTO': 'Export to',
        'NOARTBOARD': 'No artboards found.',
        'EXPORTSUCCESS': 'Export success.',
        'EXPORTFAIL': 'Export fail.',
        'NEWVERSION': 'Marketch has new version({newversion}). Please reinstalling form sketch toolbox.',
        'LAETVERSION': 'is currently the newest version available.',
        'NETERROR': 'Service is not available.',
        'SELECTEXPORTARTBOARD': 'Which artboards would you like to export?',
        'SELECTEDARTBOARD': 'Selected artboard',
        'ARTBOARDONPAGE': 'Artboards on current page',
        'ALLARTBOARD': 'All Artboards',
        'EXPORTEVERYLAYER': 'Export all layers as image',
        'REVEALINFINDER': 'Reveal in Finder after exporting',
        'CONFIRM': 'Confirm',
        'CANCEl': 'Cancel',
        // Preview page in multiple languages
        'MarketchPreview': {
          'UNIT': 'Unit',
          'SIZE': 'Size',
          'SHOWSLICE': 'Show slice',
          'DRAGTOSAVE': 'Drag to desktop to save.',
          'WIDTH': 'Width',
          'HEIGHT': 'Height',
          'BORDER': 'Border',
          'COLOR': 'color',
          'FILLCOLOR': 'Fill',
          'RADIUS': 'Radius',
          'LAYERTEXT': 'Content',
          'FONTSIZE': 'Font size',
          'CODE': 'Code',
          'EXPORT': 'Export',
          'FORMAT': 'Format',
          'EXPORTLAYER': 'Export Activity Layer',
          'COPYSUCCESS': 'Copy Success'
        }
      }
    }

    // Get the language after I18N variables to streamline operations
    if (languages != 'zh-Hans') {
      return I18N['en'];
    } else {
      return I18N['zh-cn'];
    }
  })(),

  /**
   * View OC object members
   * @param Layer {object} layer object
   * @param Type {string} View type. Available Values:
   *      class: Viewing layers inheritance chain
   *      method: Viewing layers && class methods instance methods
   *      property: View Layer Properties
   *      protoco: View Layer protocol;
   * @return Array
   */
  getMembersOfOC: function(layer, type) {
    var result = NSMutableArray.array();
    var desc = [[MOClassDescription alloc] initWithClass:[layer class] registered:nil];

    switch (type) {
      default:
        case 'class':
      // Inheritance chain
        result.addObjectsFromArray(desc.ancestors());
      break;
      case 'method':
        // Class methods (classMethodsWithAncestors)
          result.addObjectsFromArray(desc.classMethodsWithAncestors());
        // Instance method (instanceMethodsWithAncestors)
        result.addObjectsFromArray(desc.instanceMethodsWithAncestors());
        break;
      case 'property':
        //Attributes（propertiesWithAncestors）
          result.addObjectsFromArray(desc.properties());
        break;
      case 'protoco':
        // Protocol (protocolsWithAncestors)
          result.addObjectsFromArray(desc.protocols());
        break;
    }
    return result;
  },

  /**
   * NSString to js string
   * @param {NSString} NSStr string to be converted
   * @param {boolean} config.encode whether the encoded string
   * @param {boolean} config.escapeLine whether the escape string in the first "-"
   */
  toJSString: function(NSStr) {
    var config = arguments.length > 1 ? arguments[1] : null;
    var str    = new String(NSStr).toString();

    if (config && config.escapeLine) {
      str = str.replace(/\\-/g, '-');
    }

    if (config && config.encode) {
      str = encodeURIComponent(str);
    }
    return str;
  },

  // Zip files
  zipFile: function(zipFile, destination) {
    var zipTask = [[NSTask alloc] init];

    [zipTask setLaunchPath:@'/usr/bin/ditto'];
    [zipTask setArguments:[NSArray arrayWithObjects: @"-c", @"-k", @"-X", @"--rsrc", zipFile, destination, nil]];
    [zipTask launch];
    [zipTask waitUntilExit];

    if ([zipTask terminationStatus] != 0) {
      return false;
    } else {
      return true;
    }

  },

  /**
   * Get layer data
   * @param layer target layer
   * @param config.type layer types
   * @param config.zIndex
   * @return object
   */

  getLayerData: function(layer, config) {

    // Layer position in the drawing board, size: frameInArtboard
    var layerFrame = layer.frameInArtboard();
    var layerId    = util.toJSString(layer.objectID());
    var nameConfig = (config.type == 'artboard') ? {encode: true, escapeLine:true} : {encode: true};

    // Layer Basic information
    var layerData = {
      'id': layerId,
      // Default path consistent with Layers Layers id
      src: layerId,
      name: util.toJSString(layer.name(), nameConfig),
      x: Math.ceil(layerFrame.origin.x),
      y: Math.ceil(layerFrame.origin.y),
      zIndex: config.zIndex,
      width: Math.ceil(layerFrame.size.width),
      height: Math.ceil(layerFrame.size.height)
    };

    // Amendment border impact on the position of the graphics, bitmap
    if (config.type == 'shape' || config.type == 'bitmap') {

      var border      = layer.style().borders().firstObject();
      var borderWidth = null;

      if (border && border.isEnabled()) {
        borderWidth = border.thickness();

        // Position is center frame
        if (border.position() == 0) {
          layerData.x      = layerData.x - parseInt(borderWidth / 2, 10);
          layerData.y      = layerData.y - parseInt(borderWidth / 2, 10);
          layerData.width  = layerData.width + borderWidth;
          layerData.height = layerData.height + borderWidth;
        }
        // Position is outside the border
        if (border.position() == 2) {
          layerData.x      = layerData.x - borderWidth;
          layerData.y      = layerData.y - borderWidth;
          layerData.width  = layerData.width + (borderWidth * 2);
          layerData.height = layerData.height + (borderWidth * 2);
        }
      }
    }

    // For the drawing board, slice, bitmaps only return to the basic data
    if (config.type == 'artboard' || config.type == 'slice' || config.type == 'bitmap') {
      return layerData;
    }

    // Text layers
    if (config.type == 'text') {
      var textAlign  = util.getTextAlign(layer);
      var fontWeight = util.getFontWeight(layer);
      var fontStyle  = layer.style();

      // Text
      layerData.html  = util.toJSString(layer.stringValue(), {encode: true});
      layerData.style = util.filterSketchCss(layer.CSSAttributes());

      // Fixed text layer to set the fill color is not the right question post
      if (fontStyle.hasEnabledFill()) {
        var fillColor = layer.style().fill().CSSAttributeString().split(':');
        if (fillColor.length > 1) {
          layerData.style.color = util.trim(fillColor[1]);
        }
      }

      if (textAlign) {
        layerData.style['text-align'] = textAlign;
      }
      if (fontWeight) {
        layerData.style['font-weight'] = fontWeight;
      }
      return layerData;
    }

    // Graphics
    if (config.type == 'shape') {
      var shapeClassName = layer.layers().firstObject().className();
      layerData.style = util.filterSketchCss(layer.CSSAttributes());

      layerData.style.width  = layerData.width +'px';
      layerData.style.height = layerData.height +'px';

      // Copy the fillet from the css (to designers see)
      if (layerData.style['border-radius']) {

        layerData.radius = layerData.style['border-radius'];

        if (layerData.radius.split('px').length > 2) {
          layerData.radius = layerData.radius.replace(/px\s?/gi, '/');
        } else {
          layerData.radius = layerData.radius.replace('px', '');
        }
      }

      // Copy the background color from the css (to designers see)
      if (layerData.style['background']) {
        layerData.background = layerData.style['background'];
      }

      // Circular (length and width error 2px less) supplementary borderRadius property
      if (shapeClassName == 'MSOvalShape' && Math.abs(layerData.width - layerData.height) <= 2) {
        layerData.style['border-radius'] = '100%';
      }
      return layerData;
    }
  },

  trim: function(str) {
    return str.replace(/(^\s+|\s+$)/g, '');
  },

  // Processing system generates css, js object returns
  filterSketchCss: function(cssAttrs) {
    var style = {};

    for(var i=0,len=cssAttrs.count();i<len;i++){
      var cssAttr = util.toJSString(cssAttrs.objectAtIndex(i));

      if (!cssAttr.match(/\/\*[^\*]*?\*\/$/g)) {
        cssAttr = cssAttr.split(':');
        style[util.trim(cssAttr[0])] = util.trim(cssAttr[1].replace(';', ''))
      }
    }

    return style;
  }
}
